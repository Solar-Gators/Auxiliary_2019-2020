//PID variables
volatile uint8_t buttonFlag=0;
volatile uint8_t pidFlag=0;
volatile float setPoint;    //set pointtarget value
volatile float inputBias;   //initial u
volatile float input = 2730;    //input given to motor. For car would be something like %pedal. 
volatile float error;   //How far off the current rpm is from the set pointtarget value
volatile float sum_int; //Sum of total accumulated error over time
float timeEst;  //experimentally determined constant that estimates time between PID calculation updates - necessary for integral control
float Kc=13.65; //(mathmatically estiamted)
float Kc = 10;  //(through trial and error) Kc is PID constant
float tau_i=.1; //constant used for Integral control. Formally, it accounts for integral delay
//PID - currently takes ~20 seconds to fully correct when a short sudden large resistance is applied
        

//Read in RPM from CAN
//Read in throttle voltage to ADC

if ((PORTE_IN & 0x02) == 0) {   //Checks for button press then debounces - just for test
    delay(100000);
    if((PORTE_IN & 0x02) == 0) {
        PORTD.OUTCLR = PIN6_bm;     //Turns on LED to confirm PID is on
        inputBias = input;  //Gets current u(input) amount at time of button press - for car this would be something like %pedal 
        setPoint = rpm;     //Sets target rpm to current rpm
        pidFlag = 1;        //Turns on PID code
    }
}
        
        
if (pidFlag == 1) {
    error=setPoint-rpm;     //Gets error value
    //Calculates total accumulated error. timeEst is estimated value for how 
    //long its been since the last update. Without it, sum_int values become 
    //too extreme. timeEst could be replaced by a clock to be more accurate.
    sum_int += error * timeEst; 
        
    //calculates a new u(input). This is just the PID formula. Proportionate 
    //control multiplies current error by the Kc constant. Integral control 
    //multiplies total accumulated error(sum_int). that does initial u + P + I.
    input = inputBias + (Kc * error) + (Kc / tau_i * sum_int);  
            
    if (input > 4095) {  // limits input to ones that the motor can take
        input = 4095;                       
    }                               
    else if (input < 0) {    //^^
        input = 0;
    }
}
